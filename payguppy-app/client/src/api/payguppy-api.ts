/**
 * Generated by orval v7.10.0 ðŸº
 * Do not edit manually.
 * PayGuppy API Doc
 * Web3-powered EMV QR
 * OpenAPI spec version: 0.1
 */
import useSwr from 'swr';
import type {
  Key,
  SWRConfiguration
} from 'swr';

import useSWRMutation from 'swr/mutation';
import type {
  SWRMutationConfiguration
} from 'swr/mutation';

export interface CreateUserDto {
  name?: string;
  handle?: string;
  type?: string;
  auth_wallet: string;
}

export interface UpdateUserDto {
  name?: string;
  handle?: string;
}

export interface CreateMerchantDto {
  name: string;
  owner_id: number;
}

export interface CreateWalletDto {
  seed: string;
  user_id?: number;
  payment_channel_id?: number;
}

export interface CreatePaymentChannelDto {
  name: string;
  qr_text: string;
  merchant_id: number;
  blockchains: string[];
  tokens: string[];
  wallet_id?: number;
}

/**
 * @nullable
 */
export type MerchantOwnerDtoHandle = { [key: string]: unknown } | null;

export interface MerchantOwnerDto {
  id: number;
  name: string;
  /** @nullable */
  handle: MerchantOwnerDtoHandle;
}

export interface MerchantDto {
  id: number;
  name: string;
  owner_id: number;
  owner: MerchantOwnerDto;
}

export type WalletAddressDtoPrivateKey = { [key: string]: unknown };

export interface WalletAddressDto {
  privateKey: WalletAddressDtoPrivateKey;
  chain: string;
  publicKey: string;
}

/**
 * @nullable
 */
export type WalletWithAddressesDtoUserId = { [key: string]: unknown } | null;

/**
 * @nullable
 */
export type WalletWithAddressesDtoEvmAddress = { [key: string]: unknown } | null;

export interface WalletWithAddressesDto {
  id: number;
  /** @nullable */
  user_id: WalletWithAddressesDtoUserId;
  addresses: WalletAddressDto[];
  /** @nullable */
  evmAddress: WalletWithAddressesDtoEvmAddress;
}

/**
 * @nullable
 */
export type PaymentChannelResponseDtoWalletId = { [key: string]: unknown } | null;

/**
 * @nullable
 */
export type PaymentChannelResponseDtoWallet = WalletWithAddressesDto | null;

export interface PaymentChannelResponseDto {
  id: number;
  name: string;
  raw_code: string;
  type: number;
  merchant_id: number;
  blockchains: string[];
  tokens: string[];
  /** @nullable */
  wallet_id: PaymentChannelResponseDtoWalletId;
  merchant: MerchantDto;
  /** @nullable */
  wallet: PaymentChannelResponseDtoWallet;
}

export interface CreateTxDto {
  sender_id: number;
  payment_channel_id: number;
  txHash: string;
  chain: string;
  token: string;
  amount: string;
}

export type appControllerHealthCheckResponse200 = {
  data: void
  status: 200
}
    
export type appControllerHealthCheckResponseComposite = appControllerHealthCheckResponse200;
    
export type appControllerHealthCheckResponse = appControllerHealthCheckResponseComposite & {
  headers: Headers;
}

export const getAppControllerHealthCheckUrl = () => {


  

  return `https://payguppy-api-production.up.railway.app/health`
}

export const appControllerHealthCheck = async ( options?: RequestInit): Promise<appControllerHealthCheckResponse> => {
  
  const res = await fetch(getAppControllerHealthCheckUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: appControllerHealthCheckResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as appControllerHealthCheckResponse
}




export const getAppControllerHealthCheckKey = () => [`https://payguppy-api-production.up.railway.app/health`] as const;

export type AppControllerHealthCheckQueryResult = NonNullable<Awaited<ReturnType<typeof appControllerHealthCheck>>>
export type AppControllerHealthCheckQueryError = Promise<unknown>

export const useAppControllerHealthCheck = <TError = Promise<unknown>>(
   options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof appControllerHealthCheck>>, TError> & { swrKey?: Key, enabled?: boolean }, fetch?: RequestInit }
) => {
  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getAppControllerHealthCheckKey() : null);
  const swrFn = () => appControllerHealthCheck(fetchOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

export type createUserResponse201 = {
  data: void
  status: 201
}
    
export type createUserResponseComposite = createUserResponse201;
    
export type createUserResponse = createUserResponseComposite & {
  headers: Headers;
}

export const getCreateUserUrl = () => {


  

  return `https://payguppy-api-production.up.railway.app/users`
}

export const createUser = async (createUserDto: CreateUserDto, options?: RequestInit): Promise<createUserResponse> => {
  
  const res = await fetch(getCreateUserUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createUserDto,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: createUserResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as createUserResponse
}




export const getCreateUserMutationFetcher = ( options?: RequestInit) => {
  return (_: Key, { arg }: { arg: CreateUserDto }): Promise<createUserResponse> => {
    return createUser(arg, options);
  }
}
export const getCreateUserMutationKey = () => [`https://payguppy-api-production.up.railway.app/users`] as const;

export type CreateUserMutationResult = NonNullable<Awaited<ReturnType<typeof createUser>>>
export type CreateUserMutationError = Promise<unknown>

export const useCreateUser = <TError = Promise<unknown>>(
   options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof createUser>>, TError, Key, CreateUserDto, Awaited<ReturnType<typeof createUser>>> & { swrKey?: string }, fetch?: RequestInit}
) => {

  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getCreateUserMutationKey();
  const swrFn = getCreateUserMutationFetcher(fetchOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

export type findAllUsersResponse200 = {
  data: void
  status: 200
}
    
export type findAllUsersResponseComposite = findAllUsersResponse200;
    
export type findAllUsersResponse = findAllUsersResponseComposite & {
  headers: Headers;
}

export const getFindAllUsersUrl = () => {


  

  return `https://payguppy-api-production.up.railway.app/users`
}

export const findAllUsers = async ( options?: RequestInit): Promise<findAllUsersResponse> => {
  
  const res = await fetch(getFindAllUsersUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: findAllUsersResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as findAllUsersResponse
}




export const getFindAllUsersKey = () => [`https://payguppy-api-production.up.railway.app/users`] as const;

export type FindAllUsersQueryResult = NonNullable<Awaited<ReturnType<typeof findAllUsers>>>
export type FindAllUsersQueryError = Promise<unknown>

export const useFindAllUsers = <TError = Promise<unknown>>(
   options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof findAllUsers>>, TError> & { swrKey?: Key, enabled?: boolean }, fetch?: RequestInit }
) => {
  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getFindAllUsersKey() : null);
  const swrFn = () => findAllUsers(fetchOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

export type findUserByAuthWalletResponse200 = {
  data: void
  status: 200
}
    
export type findUserByAuthWalletResponseComposite = findUserByAuthWalletResponse200;
    
export type findUserByAuthWalletResponse = findUserByAuthWalletResponseComposite & {
  headers: Headers;
}

export const getFindUserByAuthWalletUrl = (authWallet: string,) => {


  

  return `https://payguppy-api-production.up.railway.app/users/auth-wallet/${authWallet}`
}

export const findUserByAuthWallet = async (authWallet: string, options?: RequestInit): Promise<findUserByAuthWalletResponse> => {
  
  const res = await fetch(getFindUserByAuthWalletUrl(authWallet),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: findUserByAuthWalletResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as findUserByAuthWalletResponse
}




export const getFindUserByAuthWalletKey = (authWallet: string,) => [`https://payguppy-api-production.up.railway.app/users/auth-wallet/${authWallet}`] as const;

export type FindUserByAuthWalletQueryResult = NonNullable<Awaited<ReturnType<typeof findUserByAuthWallet>>>
export type FindUserByAuthWalletQueryError = Promise<unknown>

export const useFindUserByAuthWallet = <TError = Promise<unknown>>(
  authWallet: string, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof findUserByAuthWallet>>, TError> & { swrKey?: Key, enabled?: boolean }, fetch?: RequestInit }
) => {
  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false && !!(authWallet)
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getFindUserByAuthWalletKey(authWallet) : null);
  const swrFn = () => findUserByAuthWallet(authWallet, fetchOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

export type updateUserResponse200 = {
  data: void
  status: 200
}
    
export type updateUserResponseComposite = updateUserResponse200;
    
export type updateUserResponse = updateUserResponseComposite & {
  headers: Headers;
}

export const getUpdateUserUrl = (id: string,) => {


  

  return `https://payguppy-api-production.up.railway.app/users/${id}`
}

export const updateUser = async (id: string,
    updateUserDto: UpdateUserDto, options?: RequestInit): Promise<updateUserResponse> => {
  
  const res = await fetch(getUpdateUserUrl(id),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updateUserDto,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: updateUserResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as updateUserResponse
}




export const getUpdateUserMutationFetcher = (id: string, options?: RequestInit) => {
  return (_: Key, { arg }: { arg: UpdateUserDto }): Promise<updateUserResponse> => {
    return updateUser(id, arg, options);
  }
}
export const getUpdateUserMutationKey = (id: string,) => [`https://payguppy-api-production.up.railway.app/users/${id}`] as const;

export type UpdateUserMutationResult = NonNullable<Awaited<ReturnType<typeof updateUser>>>
export type UpdateUserMutationError = Promise<unknown>

export const useUpdateUser = <TError = Promise<unknown>>(
  id: string, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof updateUser>>, TError, Key, UpdateUserDto, Awaited<ReturnType<typeof updateUser>>> & { swrKey?: string }, fetch?: RequestInit}
) => {

  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getUpdateUserMutationKey(id);
  const swrFn = getUpdateUserMutationFetcher(id, fetchOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

export type createMerchantResponse201 = {
  data: void
  status: 201
}
    
export type createMerchantResponseComposite = createMerchantResponse201;
    
export type createMerchantResponse = createMerchantResponseComposite & {
  headers: Headers;
}

export const getCreateMerchantUrl = () => {


  

  return `https://payguppy-api-production.up.railway.app/merchant`
}

export const createMerchant = async (createMerchantDto: CreateMerchantDto, options?: RequestInit): Promise<createMerchantResponse> => {
  
  const res = await fetch(getCreateMerchantUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createMerchantDto,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: createMerchantResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as createMerchantResponse
}




export const getCreateMerchantMutationFetcher = ( options?: RequestInit) => {
  return (_: Key, { arg }: { arg: CreateMerchantDto }): Promise<createMerchantResponse> => {
    return createMerchant(arg, options);
  }
}
export const getCreateMerchantMutationKey = () => [`https://payguppy-api-production.up.railway.app/merchant`] as const;

export type CreateMerchantMutationResult = NonNullable<Awaited<ReturnType<typeof createMerchant>>>
export type CreateMerchantMutationError = Promise<unknown>

export const useCreateMerchant = <TError = Promise<unknown>>(
   options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof createMerchant>>, TError, Key, CreateMerchantDto, Awaited<ReturnType<typeof createMerchant>>> & { swrKey?: string }, fetch?: RequestInit}
) => {

  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getCreateMerchantMutationKey();
  const swrFn = getCreateMerchantMutationFetcher(fetchOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

export type findAllMerchantsResponse200 = {
  data: void
  status: 200
}
    
export type findAllMerchantsResponseComposite = findAllMerchantsResponse200;
    
export type findAllMerchantsResponse = findAllMerchantsResponseComposite & {
  headers: Headers;
}

export const getFindAllMerchantsUrl = () => {


  

  return `https://payguppy-api-production.up.railway.app/merchant`
}

export const findAllMerchants = async ( options?: RequestInit): Promise<findAllMerchantsResponse> => {
  
  const res = await fetch(getFindAllMerchantsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: findAllMerchantsResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as findAllMerchantsResponse
}




export const getFindAllMerchantsKey = () => [`https://payguppy-api-production.up.railway.app/merchant`] as const;

export type FindAllMerchantsQueryResult = NonNullable<Awaited<ReturnType<typeof findAllMerchants>>>
export type FindAllMerchantsQueryError = Promise<unknown>

export const useFindAllMerchants = <TError = Promise<unknown>>(
   options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof findAllMerchants>>, TError> & { swrKey?: Key, enabled?: boolean }, fetch?: RequestInit }
) => {
  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getFindAllMerchantsKey() : null);
  const swrFn = () => findAllMerchants(fetchOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

export type findOneMerchantResponse200 = {
  data: void
  status: 200
}
    
export type findOneMerchantResponseComposite = findOneMerchantResponse200;
    
export type findOneMerchantResponse = findOneMerchantResponseComposite & {
  headers: Headers;
}

export const getFindOneMerchantUrl = (id: string,) => {


  

  return `https://payguppy-api-production.up.railway.app/merchant/${id}`
}

export const findOneMerchant = async (id: string, options?: RequestInit): Promise<findOneMerchantResponse> => {
  
  const res = await fetch(getFindOneMerchantUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: findOneMerchantResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as findOneMerchantResponse
}




export const getFindOneMerchantKey = (id: string,) => [`https://payguppy-api-production.up.railway.app/merchant/${id}`] as const;

export type FindOneMerchantQueryResult = NonNullable<Awaited<ReturnType<typeof findOneMerchant>>>
export type FindOneMerchantQueryError = Promise<unknown>

export const useFindOneMerchant = <TError = Promise<unknown>>(
  id: string, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof findOneMerchant>>, TError> & { swrKey?: Key, enabled?: boolean }, fetch?: RequestInit }
) => {
  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false && !!(id)
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getFindOneMerchantKey(id) : null);
  const swrFn = () => findOneMerchant(id, fetchOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

export type createWalletResponse201 = {
  data: void
  status: 201
}
    
export type createWalletResponseComposite = createWalletResponse201;
    
export type createWalletResponse = createWalletResponseComposite & {
  headers: Headers;
}

export const getCreateWalletUrl = () => {


  

  return `https://payguppy-api-production.up.railway.app/wallet`
}

export const createWallet = async (createWalletDto: CreateWalletDto, options?: RequestInit): Promise<createWalletResponse> => {
  
  const res = await fetch(getCreateWalletUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createWalletDto,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: createWalletResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as createWalletResponse
}




export const getCreateWalletMutationFetcher = ( options?: RequestInit) => {
  return (_: Key, { arg }: { arg: CreateWalletDto }): Promise<createWalletResponse> => {
    return createWallet(arg, options);
  }
}
export const getCreateWalletMutationKey = () => [`https://payguppy-api-production.up.railway.app/wallet`] as const;

export type CreateWalletMutationResult = NonNullable<Awaited<ReturnType<typeof createWallet>>>
export type CreateWalletMutationError = Promise<unknown>

export const useCreateWallet = <TError = Promise<unknown>>(
   options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof createWallet>>, TError, Key, CreateWalletDto, Awaited<ReturnType<typeof createWallet>>> & { swrKey?: string }, fetch?: RequestInit}
) => {

  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getCreateWalletMutationKey();
  const swrFn = getCreateWalletMutationFetcher(fetchOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

export type findAllWalletsResponse200 = {
  data: void
  status: 200
}
    
export type findAllWalletsResponseComposite = findAllWalletsResponse200;
    
export type findAllWalletsResponse = findAllWalletsResponseComposite & {
  headers: Headers;
}

export const getFindAllWalletsUrl = () => {


  

  return `https://payguppy-api-production.up.railway.app/wallet`
}

export const findAllWallets = async ( options?: RequestInit): Promise<findAllWalletsResponse> => {
  
  const res = await fetch(getFindAllWalletsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: findAllWalletsResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as findAllWalletsResponse
}




export const getFindAllWalletsKey = () => [`https://payguppy-api-production.up.railway.app/wallet`] as const;

export type FindAllWalletsQueryResult = NonNullable<Awaited<ReturnType<typeof findAllWallets>>>
export type FindAllWalletsQueryError = Promise<unknown>

export const useFindAllWallets = <TError = Promise<unknown>>(
   options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof findAllWallets>>, TError> & { swrKey?: Key, enabled?: boolean }, fetch?: RequestInit }
) => {
  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getFindAllWalletsKey() : null);
  const swrFn = () => findAllWallets(fetchOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

export type findOneWalletResponse200 = {
  data: void
  status: 200
}
    
export type findOneWalletResponseComposite = findOneWalletResponse200;
    
export type findOneWalletResponse = findOneWalletResponseComposite & {
  headers: Headers;
}

export const getFindOneWalletUrl = (id: string,) => {


  

  return `https://payguppy-api-production.up.railway.app/wallet/${id}`
}

export const findOneWallet = async (id: string, options?: RequestInit): Promise<findOneWalletResponse> => {
  
  const res = await fetch(getFindOneWalletUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: findOneWalletResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as findOneWalletResponse
}




export const getFindOneWalletKey = (id: string,) => [`https://payguppy-api-production.up.railway.app/wallet/${id}`] as const;

export type FindOneWalletQueryResult = NonNullable<Awaited<ReturnType<typeof findOneWallet>>>
export type FindOneWalletQueryError = Promise<unknown>

export const useFindOneWallet = <TError = Promise<unknown>>(
  id: string, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof findOneWallet>>, TError> & { swrKey?: Key, enabled?: boolean }, fetch?: RequestInit }
) => {
  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false && !!(id)
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getFindOneWalletKey(id) : null);
  const swrFn = () => findOneWallet(id, fetchOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

export type findAllBlockchainsResponse200 = {
  data: void
  status: 200
}
    
export type findAllBlockchainsResponseComposite = findAllBlockchainsResponse200;
    
export type findAllBlockchainsResponse = findAllBlockchainsResponseComposite & {
  headers: Headers;
}

export const getFindAllBlockchainsUrl = () => {


  

  return `https://payguppy-api-production.up.railway.app/blockchain`
}

export const findAllBlockchains = async ( options?: RequestInit): Promise<findAllBlockchainsResponse> => {
  
  const res = await fetch(getFindAllBlockchainsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: findAllBlockchainsResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as findAllBlockchainsResponse
}




export const getFindAllBlockchainsKey = () => [`https://payguppy-api-production.up.railway.app/blockchain`] as const;

export type FindAllBlockchainsQueryResult = NonNullable<Awaited<ReturnType<typeof findAllBlockchains>>>
export type FindAllBlockchainsQueryError = Promise<unknown>

export const useFindAllBlockchains = <TError = Promise<unknown>>(
   options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof findAllBlockchains>>, TError> & { swrKey?: Key, enabled?: boolean }, fetch?: RequestInit }
) => {
  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getFindAllBlockchainsKey() : null);
  const swrFn = () => findAllBlockchains(fetchOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

export type createPaymentChannelResponse201 = {
  data: void
  status: 201
}
    
export type createPaymentChannelResponseComposite = createPaymentChannelResponse201;
    
export type createPaymentChannelResponse = createPaymentChannelResponseComposite & {
  headers: Headers;
}

export const getCreatePaymentChannelUrl = () => {


  

  return `https://payguppy-api-production.up.railway.app/payment-channel`
}

export const createPaymentChannel = async (createPaymentChannelDto: CreatePaymentChannelDto, options?: RequestInit): Promise<createPaymentChannelResponse> => {
  
  const res = await fetch(getCreatePaymentChannelUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createPaymentChannelDto,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: createPaymentChannelResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as createPaymentChannelResponse
}




export const getCreatePaymentChannelMutationFetcher = ( options?: RequestInit) => {
  return (_: Key, { arg }: { arg: CreatePaymentChannelDto }): Promise<createPaymentChannelResponse> => {
    return createPaymentChannel(arg, options);
  }
}
export const getCreatePaymentChannelMutationKey = () => [`https://payguppy-api-production.up.railway.app/payment-channel`] as const;

export type CreatePaymentChannelMutationResult = NonNullable<Awaited<ReturnType<typeof createPaymentChannel>>>
export type CreatePaymentChannelMutationError = Promise<unknown>

export const useCreatePaymentChannel = <TError = Promise<unknown>>(
   options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof createPaymentChannel>>, TError, Key, CreatePaymentChannelDto, Awaited<ReturnType<typeof createPaymentChannel>>> & { swrKey?: string }, fetch?: RequestInit}
) => {

  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getCreatePaymentChannelMutationKey();
  const swrFn = getCreatePaymentChannelMutationFetcher(fetchOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

export type getAllPaymentChannelsResponse200 = {
  data: void
  status: 200
}
    
export type getAllPaymentChannelsResponseComposite = getAllPaymentChannelsResponse200;
    
export type getAllPaymentChannelsResponse = getAllPaymentChannelsResponseComposite & {
  headers: Headers;
}

export const getGetAllPaymentChannelsUrl = () => {


  

  return `https://payguppy-api-production.up.railway.app/payment-channel`
}

export const getAllPaymentChannels = async ( options?: RequestInit): Promise<getAllPaymentChannelsResponse> => {
  
  const res = await fetch(getGetAllPaymentChannelsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getAllPaymentChannelsResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getAllPaymentChannelsResponse
}




export const getGetAllPaymentChannelsKey = () => [`https://payguppy-api-production.up.railway.app/payment-channel`] as const;

export type GetAllPaymentChannelsQueryResult = NonNullable<Awaited<ReturnType<typeof getAllPaymentChannels>>>
export type GetAllPaymentChannelsQueryError = Promise<unknown>

export const useGetAllPaymentChannels = <TError = Promise<unknown>>(
   options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof getAllPaymentChannels>>, TError> & { swrKey?: Key, enabled?: boolean }, fetch?: RequestInit }
) => {
  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGetAllPaymentChannelsKey() : null);
  const swrFn = () => getAllPaymentChannels(fetchOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

export type getPaymentChannelsByQrResponse200 = {
  data: void
  status: 200
}
    
export type getPaymentChannelsByQrResponseComposite = getPaymentChannelsByQrResponse200;
    
export type getPaymentChannelsByQrResponse = getPaymentChannelsByQrResponseComposite & {
  headers: Headers;
}

export const getGetPaymentChannelsByQrUrl = (qrTextKeccak: string,) => {


  

  return `https://payguppy-api-production.up.railway.app/payment-channel/${qrTextKeccak}`
}

export const getPaymentChannelsByQr = async (qrTextKeccak: string, options?: RequestInit): Promise<getPaymentChannelsByQrResponse> => {
  
  const res = await fetch(getGetPaymentChannelsByQrUrl(qrTextKeccak),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getPaymentChannelsByQrResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getPaymentChannelsByQrResponse
}




export const getGetPaymentChannelsByQrKey = (qrTextKeccak: string,) => [`https://payguppy-api-production.up.railway.app/payment-channel/${qrTextKeccak}`] as const;

export type GetPaymentChannelsByQrQueryResult = NonNullable<Awaited<ReturnType<typeof getPaymentChannelsByQr>>>
export type GetPaymentChannelsByQrQueryError = Promise<unknown>

export const useGetPaymentChannelsByQr = <TError = Promise<unknown>>(
  qrTextKeccak: string, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof getPaymentChannelsByQr>>, TError> & { swrKey?: Key, enabled?: boolean }, fetch?: RequestInit }
) => {
  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false && !!(qrTextKeccak)
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGetPaymentChannelsByQrKey(qrTextKeccak) : null);
  const swrFn = () => getPaymentChannelsByQr(qrTextKeccak, fetchOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

export type getPaymentChannelsByMerchantIdResponse200 = {
  data: PaymentChannelResponseDto[]
  status: 200
}
    
export type getPaymentChannelsByMerchantIdResponseComposite = getPaymentChannelsByMerchantIdResponse200;
    
export type getPaymentChannelsByMerchantIdResponse = getPaymentChannelsByMerchantIdResponseComposite & {
  headers: Headers;
}

export const getGetPaymentChannelsByMerchantIdUrl = (merchantId: string,) => {


  

  return `https://payguppy-api-production.up.railway.app/payment-channel/merchant/${merchantId}`
}

export const getPaymentChannelsByMerchantId = async (merchantId: string, options?: RequestInit): Promise<getPaymentChannelsByMerchantIdResponse> => {
  
  const res = await fetch(getGetPaymentChannelsByMerchantIdUrl(merchantId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getPaymentChannelsByMerchantIdResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getPaymentChannelsByMerchantIdResponse
}




export const getGetPaymentChannelsByMerchantIdKey = (merchantId: string,) => [`https://payguppy-api-production.up.railway.app/payment-channel/merchant/${merchantId}`] as const;

export type GetPaymentChannelsByMerchantIdQueryResult = NonNullable<Awaited<ReturnType<typeof getPaymentChannelsByMerchantId>>>
export type GetPaymentChannelsByMerchantIdQueryError = Promise<unknown>

export const useGetPaymentChannelsByMerchantId = <TError = Promise<unknown>>(
  merchantId: string, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof getPaymentChannelsByMerchantId>>, TError> & { swrKey?: Key, enabled?: boolean }, fetch?: RequestInit }
) => {
  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false && !!(merchantId)
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGetPaymentChannelsByMerchantIdKey(merchantId) : null);
  const swrFn = () => getPaymentChannelsByMerchantId(merchantId, fetchOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

export type submitTxResponse201 = {
  data: void
  status: 201
}
    
export type submitTxResponseComposite = submitTxResponse201;
    
export type submitTxResponse = submitTxResponseComposite & {
  headers: Headers;
}

export const getSubmitTxUrl = () => {


  

  return `https://payguppy-api-production.up.railway.app/tx`
}

export const submitTx = async (createTxDto: CreateTxDto, options?: RequestInit): Promise<submitTxResponse> => {
  
  const res = await fetch(getSubmitTxUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createTxDto,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: submitTxResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as submitTxResponse
}




export const getSubmitTxMutationFetcher = ( options?: RequestInit) => {
  return (_: Key, { arg }: { arg: CreateTxDto }): Promise<submitTxResponse> => {
    return submitTx(arg, options);
  }
}
export const getSubmitTxMutationKey = () => [`https://payguppy-api-production.up.railway.app/tx`] as const;

export type SubmitTxMutationResult = NonNullable<Awaited<ReturnType<typeof submitTx>>>
export type SubmitTxMutationError = Promise<unknown>

export const useSubmitTx = <TError = Promise<unknown>>(
   options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof submitTx>>, TError, Key, CreateTxDto, Awaited<ReturnType<typeof submitTx>>> & { swrKey?: string }, fetch?: RequestInit}
) => {

  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getSubmitTxMutationKey();
  const swrFn = getSubmitTxMutationFetcher(fetchOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

export type getTxByUserIdResponse200 = {
  data: void
  status: 200
}
    
export type getTxByUserIdResponseComposite = getTxByUserIdResponse200;
    
export type getTxByUserIdResponse = getTxByUserIdResponseComposite & {
  headers: Headers;
}

export const getGetTxByUserIdUrl = (userId: number,) => {


  

  return `https://payguppy-api-production.up.railway.app/tx/user/${userId}`
}

export const getTxByUserId = async (userId: number, options?: RequestInit): Promise<getTxByUserIdResponse> => {
  
  const res = await fetch(getGetTxByUserIdUrl(userId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getTxByUserIdResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getTxByUserIdResponse
}




export const getGetTxByUserIdKey = (userId: number,) => [`https://payguppy-api-production.up.railway.app/tx/user/${userId}`] as const;

export type GetTxByUserIdQueryResult = NonNullable<Awaited<ReturnType<typeof getTxByUserId>>>
export type GetTxByUserIdQueryError = Promise<unknown>

export const useGetTxByUserId = <TError = Promise<unknown>>(
  userId: number, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof getTxByUserId>>, TError> & { swrKey?: Key, enabled?: boolean }, fetch?: RequestInit }
) => {
  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false && !!(userId)
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGetTxByUserIdKey(userId) : null);
  const swrFn = () => getTxByUserId(userId, fetchOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

export type getTxByMerchantIdResponse200 = {
  data: void
  status: 200
}
    
export type getTxByMerchantIdResponseComposite = getTxByMerchantIdResponse200;
    
export type getTxByMerchantIdResponse = getTxByMerchantIdResponseComposite & {
  headers: Headers;
}

export const getGetTxByMerchantIdUrl = (merchantId: number,) => {


  

  return `https://payguppy-api-production.up.railway.app/tx/merchant/${merchantId}`
}

export const getTxByMerchantId = async (merchantId: number, options?: RequestInit): Promise<getTxByMerchantIdResponse> => {
  
  const res = await fetch(getGetTxByMerchantIdUrl(merchantId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getTxByMerchantIdResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getTxByMerchantIdResponse
}




export const getGetTxByMerchantIdKey = (merchantId: number,) => [`https://payguppy-api-production.up.railway.app/tx/merchant/${merchantId}`] as const;

export type GetTxByMerchantIdQueryResult = NonNullable<Awaited<ReturnType<typeof getTxByMerchantId>>>
export type GetTxByMerchantIdQueryError = Promise<unknown>

export const useGetTxByMerchantId = <TError = Promise<unknown>>(
  merchantId: number, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof getTxByMerchantId>>, TError> & { swrKey?: Key, enabled?: boolean }, fetch?: RequestInit }
) => {
  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false && !!(merchantId)
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGetTxByMerchantIdKey(merchantId) : null);
  const swrFn = () => getTxByMerchantId(merchantId, fetchOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

export type getTxByPaymentChannelIdResponse200 = {
  data: void
  status: 200
}
    
export type getTxByPaymentChannelIdResponseComposite = getTxByPaymentChannelIdResponse200;
    
export type getTxByPaymentChannelIdResponse = getTxByPaymentChannelIdResponseComposite & {
  headers: Headers;
}

export const getGetTxByPaymentChannelIdUrl = (paymentChannelId: number,) => {


  

  return `https://payguppy-api-production.up.railway.app/tx/payment-channel/${paymentChannelId}`
}

export const getTxByPaymentChannelId = async (paymentChannelId: number, options?: RequestInit): Promise<getTxByPaymentChannelIdResponse> => {
  
  const res = await fetch(getGetTxByPaymentChannelIdUrl(paymentChannelId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getTxByPaymentChannelIdResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getTxByPaymentChannelIdResponse
}




export const getGetTxByPaymentChannelIdKey = (paymentChannelId: number,) => [`https://payguppy-api-production.up.railway.app/tx/payment-channel/${paymentChannelId}`] as const;

export type GetTxByPaymentChannelIdQueryResult = NonNullable<Awaited<ReturnType<typeof getTxByPaymentChannelId>>>
export type GetTxByPaymentChannelIdQueryError = Promise<unknown>

export const useGetTxByPaymentChannelId = <TError = Promise<unknown>>(
  paymentChannelId: number, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof getTxByPaymentChannelId>>, TError> & { swrKey?: Key, enabled?: boolean }, fetch?: RequestInit }
) => {
  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false && !!(paymentChannelId)
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGetTxByPaymentChannelIdKey(paymentChannelId) : null);
  const swrFn = () => getTxByPaymentChannelId(paymentChannelId, fetchOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}
